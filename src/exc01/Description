                                        Аннотации.
    Аннотация - языковое средство(информация), позволяющее встраивать справочную информации в
исходные файлы, не меняя порядок выполнения программы. Эта информация может быть использована
различными инструментальными средствами на стадии разработки или развертывания прикладных прог-
рамм на Java. Например, аннотация может обрабатываться генераторами исходного кода.

                              Остновы аннотирования программ.
    Аннотации создаются с помощью механизма, основанного на интеафейсе.

Пример.
    Объявление аннотации.

    // Простой тип аннотации
    @interface MyAnnotation {
        String str();
        int val();
    }

    Знак @, предваряющий ключевое слово interface. Этим компилятору указывается, что объявлен тип
аннотации. Далее обратите внимание на два метода - str() и val(). Все аннотации состоят только из
объявлений методов. Но тела этих методов в них не определяются. Вместо это­го они реализуются сред-
ствами Java. Более того, эти методы ведут себя аналогично полям.
    Объявление аннотации НЕ МОЖЕТ включать в себя ключевое слово extends. Но все аннотации автома-
тически расширяют интерфейс Annotation. Это означает, что Annotation является суперинтерфейсом для
всех аннотаций. Он объявлен в пакете java.lang.annotation. В интерфейсе Annotation переопределяются
методы hashCode(), equals() и toString(), определенные в классе Object. В нем также объявляется ме-
тод annotationType(), возвращающий объект типа Class, представляющий вызывающую аннотацию.
    Как только аннотация будет объявлена, ею можно воспользоваться для аннотирования любых элементов
прикладного кода.
    Аннотацию можно связать с любым объявлением. Например, аннотировать можно классы, методы, поля,
параметры и константы перечислимого типа. Аннотированной может быть даже сама анно­тация. Но в любом
случае аннотация предшествует остальной части объявления.
    Когда применяется аннотация, ее членам присваиваются соответствующие значения.
Пример.

    // Аннотирование метода
    @MyAnnotation(str = "Пример аннотации", val = 100)
    public static void myMeth() { // . . .

    Эта аннотация связана с методом myMeth(). Обратите особое внимание на ее синтаксис. Сразу за
именем аннотации, которому предшествует знак @, следует список инициализируемых ее членов в скобках.
Чтобы установить значение члена аннотации, достаточно присвоить его имени данного члена. Таким обра-
зом, в данном примере строка "Пример аннотации" присваивается члену str аннотации MyAnnotation. Обра-
тите также внимание на то, что в этом присваивании нет никаких скобок после имени члена str. Когда
члену аннотации присваивается значение, используется только его имя. В данном контексте члены похожи
на поля.


                                Правила удержания аннотации.
    Правила удержания определяют момент, когда аннотация отбрасывается. В Java определены три такие
правила, инкапсулированные в перечисление java.lang.annotation.RetentionPolicy. Это правила SOURCE,
CLASS и RUNTIME.
    Аннотации по правилу удержания SOURCE содержатся только в исходном файле и отбрасываются при ком-
пиляции.
    Аннотации по правилу удержания CLASS сохра­няются в файле с расширением .class во время компиляции.
Но они недоступны для виртуальной машины JVM во время выполнения.
    Аннотации по правилу удер­жания RUNTIME сохраняются в файле с расширением .class во время компиля-
ции и остаются доступными для виртуальной машины JVМ во время выполнения. Это означает, что правило
удержания RUNTIME предоставляет аннотации наиболее высокую степень сохраняемости.
    Правило удержания аннотации задается с помощью одной из встроенных анно­тации Java: @Retention,
общая форма которой приведена ниже.

    @Retention (правило_удержания)

    Здесь правило_удержания должно быть обозначено одной из описанных ранее констант. Если для аннота-
ции не указано никакого правила удержания, то применяется правило удержания CLASS.
    В следующем примере аннотации MyAnnotation правило удержания RUNTIME устанав­ливается с помощью
аннотации @Retention. Это означает, что аннотация MyAnnotation будет доступна для виртуальной машины
JVМ во время выполнения программы.

    @Retention (RetentionPolicy.RUNTIME)
    @interface MyAnnotation {
        String str();
        int val();
    }


                            Получение аннотации во время выполнения
                                     с помощью рефлексии.
    Аннотация предназначена в основном для использования в инструментальных средствах разработки и
развертывания прикладных программ на Java. Но если они задают правило удержания RUNTIME, то могут
быть опрошены во время выполнения в любой программе на Java с помощью рефлексии.
    Рефлексия - это языковое средство для получения сведений о классе во время выполнения программы.
Приклодной Програмный Интерфейс(API) для рефлексии входит в состав пакета java.lang.reflect.
    Первый шаг с целью воспользоваться рефлексией состоит в получении объек­та типа Class. Этот объект
представляет класс, аннотацию которого требуется получить.А Class относится к числу встроенных в Java
классов и определенвпакете java.lang. Получеть объект типа Class - вызвать метод getClass(), опреде-
ленный в классе Object. Этот метод возвращает объект типа Class, который представляет вызыва­ющий объект.

final Class<?> getClass ()

    Имея в своем распоряжении объект типа Class, можно воспользоваться его методами для получения све-
дений о различных элементах, объявленных в классе, включая и его аннотацию. Если требуются аннотации,
связанные с определенным элементом, объявленным в классе, сначала следует получить объект, представляю­
щий этот элемент. Например, класс Class предоставляет (среди прочего) методы getMethod(), getField() и
getConstructor(), возвращающие сведения о мето­ де, поле и конструкторе соответственно. Эти методы воз-
вращают объекты типа Method, Field и Constructor.
    Рассмотрим в качестве примера получение аннотаций, связанных с методом. Сначала получается объект
типа Class, затем вызывается метод getMethod() для этого объекта с указанным именем искомого метода.
Метод имеет форму:

Method qetMethod(String имя_метода, Class<?> ... типы_параметров)

    Имя искомого метода передается в качестве аргумента имя_метода. Если этот метод принимает аргументы,
то объекты типа Class, представляющие их типы, должны быть также указаны в качестве аргумента типы_пара-
метров. Обратите внимание на то, что аргумент типы_параметров представляет собой список ар­гументов пере-
менной длины. Это позволяет задать столько типов параметров, сколько требуется, в том числе и не указы-
вать их вообще. Метод getMethod() возвращает объект типа Method, который представляет метод. Если метод
не удается найти, то генерируется исключение типа NoSuchMethodException.
    Из объекта типа Class, Method, Field или Constructor можно получить кон­ кретные аннотации, связанные
с этим объектом, вызвав метод getAnnotation(). Его общая форма приведена ниже.

<А extends Annotation> getAnnotation (Class<A> тип_аннотации)

    Здесь параметр тип_аннотации обозначает объект типа Class, представля­ ющий требующуюся аннотацию.
Этот метод возвращает ссылку на аннотацию. Используя эту ссылку, можно получить значения, связанные с чле-
нами аннотации. Метод getAnnotation() возвращает пустое значение null, если аннотация не найдена. В этом
случае у искомой аннотации отсутствует аннотация @Retention, устанавливающая правило удержания RUNTIME.


ПРИМЕР.
    В этой программе рефлексия приме­няется для вывода аннотации, связанной с конкретным методом, для полу-
чения и вывода значений переменных str и val из аннотации MyAnnotation, связанной с мето­ дом myMeth() из
класса Meta. Здесь следует обратить особое внимание на следующее. Во-первых, это выражение
MyAnnotation.class в следующей строке кода:

MyAnnotation annotation = m.getAnnotation(MyAnnotation.class);

    Это выражение вычисляется как объект Class, относящийся к типу MyAnnotation, т.е. к искомой аннотации,
и называется  л и т е р а л о м  класса. Такое выражение можно использовать всякий раз, когда требуется
объект Class известного класса. Например, в следующем операторе получается объект Class для класса Meta:

Class<?> с = Meta.class;

    Безусловно, такой подход годится лишь в том случае, если заранее известно имя класса искомого объекта,
что возможно далеко не всегда. В общем, литерал класса можно получить для классов, интерфейсов, примитивных
типов и массивов.
    И во-вторых, это способ получения значений, связанных с переменными str и val, когда они выводятся в
следующей строке кода: System.out.println(annotation.str() + " " + annotation.val());
    Обратите внимание на то, что для обращения к ним применяется синтаксис вызова методов. Тот же самый
подход применяется всякий раз, когда требуется получить член аннотации.














































